# Advanced CUE Language

## Философия языка

CUE создан, чтобы избавиться от привычки думать о конфигурациях в терминах *наследования* или *переопределения*. Вместо этого он оперирует **значениями**, которые могут быть более или менее конкретными, и объединяет их в **иерархию точности** — решетку.

### Типы — это значения

В CUE `string` — это просто широкое значение, а `"hello"` — это более узкое, конкретное значение.

```cue
var1: string      // любое текстовое значение
var2: "hello"     // конкретное текстовое значение "hello"
```

В CUE нет жесткого различия между типами и значениями. Типы — это просто абстрактные значения, а конкретные значения — частные случаи этих типов.

## Решетчатая модель (Lattice Model)

CUE строит все значения и типы в виде **иерархии от общего к конкретному**. Математически это называется **решетка (lattice)**.

### Основные уровни решетки

1. **Top (`_`)** – самый абстрактный уровень. Любое значение подходит.

   ```cue
   any: _
   ```
2. **Types** – типы данных, более конкретные, чем `_`.

   ```cue
   t1: string
   t2: int
   ```
3. **Constraints** – уточненные типы.

   ```cue
   c1: int & >10
   c2: string & =~"hello.*"
   ```
   Используются для валидации и устранения boilerplate
4. **Concrete Values** – самые конкретные значения.

   ```cue
   val1: 42
   val2: "hello world"
   ```
5. **Bottom (`_|_`)** – противоречивые или недопустимые значения.

   ```cue
   invalid: 42 & "hello" // результат: _|_
   ```

### Основные операции решетки

#### Конъюнкция (`&`)

Находит **наибольшую нижнюю грань** (most specific common refinement) двух значений:

```cue
int & >10    // int больше 10
42 & int     // 42
42 & string  // _|_ (противоречие)
```

#### Дизъюнкция (`|`)

Создает объединенный тип — значение может быть любым из указанных:

```cue
string | int   // значение может быть либо string, либо int
```

Таким образом, благодаря решетке мы получаем следующий набор преимуществ: 

1. **Независимость от порядка**
   Комбинация значений всегда коммутативна:

   ```cue
   a: int & >0
   b: >0 & int   // a & b == b & a
   ```

2. **Отсутствие переопределений**
   Вы не можете «заменить» значение другим. Любое несоответствие вызывает ошибку:

   ```cue
   x: 1
   y: 2 & x   // ошибка, 1 & 2 == _|_
   ```

3. **Единая проверка подлинности**
   Схемы — это просто абстрактные значения. Проверка данных — это объединение с схемой:

   ```cue
   schema: string & =~"hello.*"
   data: "hello cue"
   valid: schema & data   // результат "hello cue", данные верны

   data2: "bye"
   invalid: schema & data2 // _|_, данные не соответствуют схеме
   ```
